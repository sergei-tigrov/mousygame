<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="–ú—ã—à–∏–Ω—ã–µ –ü—Ä—è—Ç–∫–∏">
    <meta name="theme-color" content="#FF6B6B">
    <title>üê≠ –ú–´–®–ò–ù–´–ï –ü–†–Ø–¢–ö–ò - CROSS-PLATFORM</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: 'Arial', 'Helvetica', 'Segoe UI', -apple-system, sans-serif;
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 50%, #6BCB77 100%);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; color: white;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .container {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            overflow: hidden;
            -webkit-text-size-adjust: 100%;
        }
        #gameCanvas {
            border: 2px solid #FFD93D;
            background: linear-gradient(135deg, #FFE66D 0%, #F4F4F4 50%, #A8E6CF 100%);
            box-shadow: 0 0 40px rgba(255, 107, 107, 0.6), inset 0 0 20px rgba(255, 255, 255, 0.3);
            cursor: crosshair;
            display: block;
            image-rendering: crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            -ms-touch-action: none;
            touch-action: none;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        /* Safari/iOS fixes */
        #gameCanvas {
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        .ui-overlay {
            position: absolute; width: 100%; height: 100%;
            display: flex; flex-direction: column; pointer-events: none;
        }
        .ui-top {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; font-size: 14px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); gap: 5px; flex-wrap: wrap;
        }
        .ui-bottom {
            padding: 10px; text-align: center; font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        .stat {
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.8), rgba(255, 217, 61, 0.8));
            border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3); font-weight: bold;
            font-size: 12px;
        }
        .menu-screen, .pause-screen, .level-complete-screen, .game-over-screen {
            position: absolute; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
            overflow-y: auto;
        }
        .menu-screen.active, .pause-screen.active, .level-complete-screen.active, .game-over-screen.active {
            display: flex;
        }
        .menu-content { text-align: center; animation: slideIn 0.5s ease-out; padding: 20px; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        .title { font-size: clamp(28px, 8vw, 56px); margin-bottom: 15px; text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7); }
        .menu-content p { font-size: clamp(14px, 4vw, 18px); margin: 8px 0; opacity: 0.95; }
        .button {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
            color: white; border: 2px solid white; padding: 10px 20px;
            font-size: clamp(14px, 4vw, 18px); border-radius: 8px; cursor: pointer; margin: 6px;
            transition: all 0.3s ease; font-weight: bold;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .button:hover, .button:active { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
        .button:active { transform: scale(0.98); }
        .hint { font-size: clamp(12px, 3vw, 14px); opacity: 0.75; margin-top: 15px; line-height: 1.4; }

        /* Virtual Controls */
        #virtualControls {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            z-index: 50;
        }
        .control-group {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            gap: 5px;
            margin-bottom: 8px;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }

        @keyframes tipFade {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive design for tablets */
        @media (max-width: 1024px) {
            .ui-top { padding: 8px; font-size: 12px; gap: 4px; }
            .ui-bottom { padding: 8px; font-size: 11px; }
            .stat { padding: 6px 10px; font-size: 11px; }
        }

        /* Responsive design for mobile phones */
        @media (max-width: 768px) {
            #gameCanvas { border: 1px solid #FFD93D; }
            .ui-top { padding: 6px; font-size: 11px; gap: 3px; }
            .ui-bottom { padding: 6px; font-size: 10px; }
            .stat { padding: 5px 8px; font-size: 10px; border-radius: 6px; }
            .button { padding: 8px 16px; font-size: clamp(12px, 3.5vw, 14px); margin: 4px; }
            .title { font-size: clamp(24px, 7vw, 40px); margin-bottom: 10px; }
            .menu-content p { font-size: clamp(12px, 3vw, 14px); margin: 6px 0; }
            #virtualControls { display: flex; flex-direction: column; }
        }

        /* Small phones */
        @media (max-width: 480px) {
            #gameCanvas { border: 1px solid #FFD93D; }
            .ui-top { padding: 4px; font-size: 10px; gap: 2px; flex-direction: column; align-items: flex-start; }
            .ui-bottom { padding: 4px; font-size: 9px; }
            .stat { padding: 4px 6px; font-size: 9px; border-radius: 4px; }
            .button { padding: 8px 12px; font-size: clamp(12px, 3vw, 13px); margin: 3px; }
            .title { font-size: clamp(20px, 6vw, 32px); margin-bottom: 8px; }
            .menu-content p { font-size: clamp(11px, 2.5vw, 12px); margin: 4px 0; }
            .menu-content { padding: 15px; }
            .hint { font-size: clamp(10px, 2vw, 11px); }
            .control-group { grid-template-columns: 50px 50px 50px; }
            .control-btn { width: 45px; height: 45px; font-size: 18px; }
        }

        /* Landscape mode */
        @media (max-height: 500px) and (orientation: landscape) {
            .ui-top { padding: 4px; font-size: 10px; }
            .ui-bottom { padding: 4px; font-size: 9px; }
            .stat { padding: 4px 6px; font-size: 9px; }
        }

        /* Safe area for notched devices */
        @supports (padding: max(0px)) {
            body {
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="gameCanvas"></canvas>
        <div id="virtualControls">
            <div class="control-group">
                <div style="grid-column: 1;"></div>
                <button class="control-btn" id="btn-up" data-key="ArrowUp">‚ñ≤</button>
                <div style="grid-column: 3;"></div>
            </div>
            <div class="control-group">
                <button class="control-btn" id="btn-left" data-key="ArrowLeft">‚óÑ</button>
                <div style="grid-column: 2;"></div>
                <button class="control-btn" id="btn-right" data-key="ArrowRight">‚ñ∫</button>
            </div>
            <div class="control-group">
                <div style="grid-column: 1;"></div>
                <button class="control-btn" id="btn-down" data-key="ArrowDown">‚ñº</button>
                <div style="grid-column: 3;"></div>
            </div>
            <div class="control-group">
                <button class="control-btn" id="btn-shift" data-key="Shift" style="grid-column: 1 / 2; background: rgba(255, 200, 100, 0.3); border-color: rgba(255, 200, 100, 0.6);">‚ö°</button>
                <button class="control-btn" id="btn-space" data-key="Space" style="grid-column: 2 / 3;">‚è∏</button>
                <button class="control-btn" id="btn-tab" data-key="Tab" style="grid-column: 3 / 4;">üê≠</button>
            </div>
        </div>
        <div class="ui-overlay">
            <div class="ui-top">
                <div class="stat">üê≠ <span id="miceCount">0</span> HP: <span id="miceHP">0</span></div>
                <div class="stat">üßÄ <span id="cheeseCount">0</span>/<span id="totalCheese">0</span></div>
                <div class="stat">‚≠ê <span id="levelNumber">1</span></div>
                <div class="stat">‚ö° <span id="stamina">100</span>%</div>
                <div class="stat">FPS: <span id="fps">60</span></div>
            </div>
            <div style="flex: 1;"></div>
            <div class="ui-bottom" id="controls">
                WASD/‚Üë‚Üì‚Üê‚Üí –¥–≤–∏–∂–µ–Ω–∏–µ | SHIFT —Å–ø—Ä–∏–Ω—Ç | –ü–†–û–ë–ï–õ –ø–∞—É–∑–∞ | TAB –º—ã—à—å | E –Ω–æ—Ä–∫–∞
            </div>
        </div>

        <div class="menu-screen active" id="menuScreen">
            <div class="menu-content">
                <div class="title">üê≠ –ú–´–®–ò–ù–´–ï –ü–†–Ø–¢–ö–ò üëÄ</div>
                <p>–ü–æ–º–æ–≥–∏ –º—ã—à–∫–∞–º —Å–ø—Ä—è—Ç–∞—Ç—å—Å—è –æ—Ç –∫–æ—à–µ–∫!</p>
                <p style="font-size: 11px; opacity: 0.6; margin-bottom: 10px;">–í–µ—Ä—Å–∏—è <span id="versionDisplay">2.2.0</span></p>
                <button class="button" onclick="startGame()">‚ñ∂Ô∏è –ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
                <div class="hint" id="menuTip" style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 15px;
                    border-radius: 10px;
                    margin-top: 20px;
                    border-left: 4px solid #FFD93D;
                    min-height: 60px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    animation: tipFade 0.5s ease-in;
                ">
                    –ó–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...
                </div>
                <button class="button" onclick="rotateTip()" style="
                    background: transparent;
                    border: 1px solid #FFD93D;
                    padding: 8px 16px;
                    margin-top: 10px;
                    font-size: 12px;
                ">‚Üª –î–†–£–ì–û–ô –°–û–í–ï–¢</button>
            </div>
        </div>

        <div class="pause-screen" id="pauseScreen">
            <div class="menu-content">
                <div class="title">‚è∏Ô∏è –ü–ê–£–ó–ê</div>
                <button class="button" onclick="resumeGame()">‚ñ∂Ô∏è –ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
                <button class="button" onclick="menuGame()">üè† –í –ú–ï–ù–Æ</button>
            </div>
        </div>

        <div class="level-complete-screen" id="levelCompleteScreen">
            <div class="menu-content">
                <div class="title">üéâ –£–†–û–í–ï–ù–¨ –ü–†–û–ô–î–ï–ù!</div>
                <p id="levelCompleteText"></p>
                <button class="button" onclick="nextLevel()">‚ñ∂Ô∏è –°–õ–ï–î–£–Æ–©–ò–ô –£–†–û–í–ï–ù–¨</button>
            </div>
        </div>

        <div class="game-over-screen" id="gameOverScreen">
            <div class="menu-content">
                <div class="title">üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</div>
                <div style="
                    background: rgba(0, 0, 0, 0.3);
                    padding: 20px;
                    border-radius: 15px;
                    margin: 15px 0;
                    border-left: 4px solid #FF5722;
                ">
                    <p id="gameOverText" style="margin: 0;"></p>
                </div>
                <div id="statsPanel" style="
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 10px;
                    margin: 15px 0;
                ">
                </div>
                <div id="scoreInputPanel" style="display: none;">
                    <input type="text" id="playerName" placeholder="–í–≤–µ–¥–∏ —Å–≤–æ—ë –∏–º—è..." maxlength="20" style="
                        padding: 12px;
                        font-size: 18px;
                        border: 2px solid #FFD93D;
                        border-radius: 10px;
                        margin: 15px 0;
                        text-align: center;
                        background: rgba(255, 255, 255, 0.9);
                        color: #333;
                    ">
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="button" onclick="saveScore()">üíæ –°–û–•–†–ê–ù–ò–¢–¨</button>
                        <button class="button" onclick="skipScoreSave()">‚è≠Ô∏è –ü–†–û–ü–£–°–¢–ò–¢–¨</button>
                    </div>
                </div>
                <button class="button" id="leaderboardBtn" onclick="showLeaderboard()" style="margin-top: 10px;">‚≠ê –†–ï–ô–¢–ò–ù–ì</button>
                <button class="button" onclick="menuGame()">üè† –í –ú–ï–ù–Æ</button>
            </div>
        </div>

        <div class="game-over-screen" id="leaderboardScreen" style="display: none;">
            <div class="menu-content">
                <div class="title">‚≠ê –¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í</div>
                <div id="leaderboardContent" style="
                    background: rgba(0, 0, 0, 0.3);
                    padding: 20px;
                    border-radius: 15px;
                    margin: 20px 0;
                    max-height: 400px;
                    overflow-y: auto;
                    text-align: left;
                "></div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="button" onclick="hideLeaderboard()">‚Üê –ù–ê–ó–ê–î</button>
                    <button class="button" onclick="menuGame()">üè† –í –ú–ï–ù–Æ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== –í–ï–†–°–ò–Ø –ò–ì–†–´ ====================
        const GAME_VERSION = '2.2.0'; // CRITICAL FIX: Safari/iOS - —Ü–≤–µ—Ç–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã –≤–º–µ—Å—Ç–æ —ç–º–æ–¥–∑–∏, –ø–æ–ª–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

        // ==================== CROSS-PLATFORM & MOBILE SUPPORT ====================
        const isTouchDevice = () => (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
        const isMobileDevice = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOSSafari = () => /Safari/.test(navigator.userAgent) && /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;

        let devicePixelRatio = window.devicePixelRatio || 1;
        let lastOrientationCheck = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';

        // ==================== –†–ï–ù–î–ï–†–ò–ù–ì –≠–ú–û–î–ó–ò - –ü–†–û–°–¢–ê–Ø –°–ò–°–¢–ï–ú–ê ====================
        function drawEmoji(ctx, emoji, x, y, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px Arial, -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, x, y);
            ctx.restore();
        }

        // –¶–≤–µ—Ç–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã - –ø—Ä–æ—Å—Ç—ã–µ –∏ –≤–∏–¥–Ω—ã –≤–µ–∑–¥–µ
        function drawCircle(ctx, x, y, radius, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawSquare(ctx, x, y, size, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.fillRect(x - size / 2, y - size / 2, size, size);
            ctx.strokeRect(x - size / 2, y - size / 2, size, size);
            ctx.restore();
        }

        function drawDiamond(ctx, x, y, size, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x + size / 2, y);
            ctx.lineTo(x, y + size / 2);
            ctx.lineTo(x - size / 2, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function getOptimalCanvasSize() {
            const width = window.innerWidth * 0.98;
            const height = window.innerHeight * 0.88;
            const maxWidth = 2400;
            const maxHeight = 1800;
            return {
                width: Math.min(width, maxWidth),
                height: Math.min(height, maxHeight),
                dpr: devicePixelRatio
            };
        }

        // ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ====================
        const CONFIG = {
            friction: 0.82,
            mouseSpeed: 1.5,           // –ü–æ–Ω–∏–∂–µ–Ω–∞ –±–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            mouseSprintSpeed: 2.8,     // –£—Å–∫–æ—Ä–µ–Ω–∏–µ –Ω–∞ Shift (–∑–∞–º–µ—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç: 1.86x)
            mouseMaxHP: 100,
            catDamage: 3,
            catSpeed: 2.0,
            catChaseSpeed: 2.8,
            catVisionRange: 220,
            catVisionAngle: 110,
            catHearingRange: 150,
            obstacleSize: 40,
            cheeseSize: 20,
            mouseSize: 25,
            catSize: 28,
            maxStamina: 100,
            staminaDecayRun: 2.0,      // –ë—ã—Å—Ç—Ä–µ–µ –∏—Å—Ç–æ—â–∞–µ—Ç—Å—è —Å—Ç–∞–º–∏–Ω–∞ –Ω–∞ —Å–ø—Ä–∏–Ω—Ç–µ
            staminaRecovery: 0.6,      // –ú–µ–¥–ª–µ–Ω–Ω–µ–µ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è
            noiseDecay: 2,
            healingSpeed: 0.5,
            burrowRadius: 35,
        };

        function getLevelConfig(level) {
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—Ä–∞–≥–æ–≤ —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ª–∞–≥–∞ –Ω–∞ –≤—ã—Å–æ–∫–∏—Ö —É—Ä–æ–≤–Ω—è—Ö
            const maxCats = 8;
            const maxMice = 8;

            const base = {
                mice: Math.min(1 + Math.floor((level - 1) / 1), maxMice),
                cats: Math.min(1 + Math.floor((level - 1) / 1), maxCats),
                cheese: 3 + (level - 1) * 2,
                obstacles: Math.min(8 + (level - 1) * 2, 25), // –ú–∞–∫—Å–∏–º—É–º 25 –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                burrows: 1,
                traps: Math.max(0, Math.min(level - 2, 5)), // –ú–∞–∫—Å–∏–º—É–º 5 –º—ã—à–µ–ª–æ–≤–æ–∫
            };

            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è, —á—Ç–æ–±—ã –Ω–µ –≤—ã—Ö–æ–¥–∏–ª –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –æ–∫–Ω–∞ –±—Ä–∞—É–∑–µ—Ä–∞
            const maxWidth = Math.min(window.innerWidth * 0.95, 2400);
            const maxHeight = Math.min(window.innerHeight * 0.85, 1800);

            let roomWidth = 1000 + (level - 1) * 150;
            let roomHeight = 800 + (level - 1) * 100;

            // –ù–µ –ø—Ä–µ–≤—ã—à–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
            roomWidth = Math.min(roomWidth, maxWidth);
            roomHeight = Math.min(roomHeight, maxHeight);

            return { ...base, roomWidth, roomHeight };
        }

        // ==================== –ü–†–û–°–¢–†–ê–ù–°–¢–í–ï–ù–ù–ê–Ø –°–ï–¢–ö–ê ====================
        class SpatialGrid {
            constructor(width, height, cellSize = 100) {
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = Array(this.cols * this.rows).fill(null).map(() => ({
                    mice: [], cats: [], obstacles: [], items: []
                }));
            }

            getCell(x, y) {
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return null;
                return this.grid[row * this.cols + col];
            }

            getNearby(x, y, distance) {
                const result = { mice: [], cats: [], obstacles: [], items: [] };
                const minCol = Math.max(0, Math.floor((x - distance) / this.cellSize));
                const maxCol = Math.min(this.cols - 1, Math.floor((x + distance) / this.cellSize));
                const minRow = Math.max(0, Math.floor((y - distance) / this.cellSize));
                const maxRow = Math.min(this.rows - 1, Math.floor((y + distance) / this.cellSize));

                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.grid[row * this.cols + col];
                        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –≤–º–µ—Å—Ç–æ spread –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–∏–∫–ª (–±—ã—Å—Ç—Ä–µ–µ –Ω–∞ –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–∞—Ö)
                        for (let i = 0; i < cell.mice.length; i++) result.mice.push(cell.mice[i]);
                        for (let i = 0; i < cell.cats.length; i++) result.cats.push(cell.cats[i]);
                        for (let i = 0; i < cell.obstacles.length; i++) result.obstacles.push(cell.obstacles[i]);
                        for (let i = 0; i < cell.items.length; i++) result.items.push(cell.items[i]);
                    }
                }
                return result;
            }

            clear() {
                for (let i = 0; i < this.grid.length; i++) {
                    this.grid[i].mice.length = 0;
                    this.grid[i].cats.length = 0;
                    this.grid[i].obstacles.length = 0;
                    this.grid[i].items.length = 0;
                }
            }

            insert(type, x, y, obj) {
                const cell = this.getCell(x, y);
                if (cell) cell[type].push(obj);
            }
        }

        // ==================== –ü–£–õ–õ –ß–ê–°–¢–ò–¶ ====================
        class ParticlePool {
            constructor(size = 500) {
                this.pool = [];
                this.active = [];
                for (let i = 0; i < size; i++) {
                    this.pool.push({
                        x: 0, y: 0, vx: 0, vy: 0, life: 0, emoji: '‚ú®'
                    });
                }
            }

            get(x, y, emoji = '‚ú®') {
                const p = this.pool.length > 0 ? this.pool.pop() :
                    { x: 0, y: 0, vx: 0, vy: 0, life: 0, emoji: '‚ú®' };
                p.x = x;
                p.y = y;
                p.vx = (Math.random() - 0.5) * 6;
                p.vy = (Math.random() - 0.5) * 6 - 2;
                p.life = 1;
                p.emoji = emoji;
                this.active.push(p);
                return p;
            }

            update() {
                // –õ–∏–º–∏—Ç–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã —á—Ç–æ–±—ã –Ω–µ —Ç–æ—Ä–º–æ–∑–∏—Ç—å –Ω–∞ 6+ —É—Ä–æ–≤–Ω—è—Ö
                const maxActive = 150;
                if (this.active.length > maxActive) {
                    // –£–¥–∞–ª—è–µ–º —Å–∞–º—ã–µ —Å—Ç–∞—Ä—ã–µ —á–∞—Å—Ç–∏—Ü—ã
                    const toRemove = this.active.length - maxActive;
                    for (let j = 0; j < toRemove; j++) {
                        const p = this.active.shift();
                        this.pool.push(p);
                    }
                }

                for (let i = this.active.length - 1; i >= 0; i--) {
                    const p = this.active[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life -= 0.05;
                    if (p.life <= 0) {
                        this.pool.push(this.active.splice(i, 1)[0]);
                    }
                }
            }

            draw(ctx) {
                for (let i = 0; i < this.active.length; i++) {
                    const p = this.active[i];
                    ctx.globalAlpha = p.life;
                    // –ß–∞—Å—Ç–∏—Ü—ã - –ø—ã—Ç–∞–µ–º—Å—è —ç–º–æ–¥–∑–∏, –Ω–æ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã
                    drawEmoji(ctx, p.emoji, p.x, p.y, 20 * p.life);
                }
            }
        }

        // ==================== –ö–õ–ê–°–°–´ ====================
        class Mouse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = CONFIG.mouseSize;
                this.alive = true;
                this.emoji = 'üê≠';
                this.stamina = CONFIG.maxStamina;
                this.isSprinting = false;
                this.noiseLevel = 0;
                this.hidden = false;
                this.hp = CONFIG.mouseMaxHP;
                this.inBurrow = false;
                this.burrowHealingTimer = 0;
            }

            update(grid, input, gameState) {
                if (!this.alive) return;

                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                let isMoving = false;
                const isSelected = gameState.selectedMouse === gameState.mice.indexOf(this);
                const speed = (input.keys['Shift'] && this.stamina > 20) ? CONFIG.mouseSprintSpeed : CONFIG.mouseSpeed;

                if (input.keys['w'] || input.keys['ArrowUp']) { this.vy -= speed; isMoving = true; }
                if (input.keys['s'] || input.keys['ArrowDown']) { this.vy += speed; isMoving = true; }
                if (input.keys['a'] || input.keys['ArrowLeft']) { this.vx -= speed; isMoving = true; }
                if (input.keys['d'] || input.keys['ArrowRight']) { this.vx += speed; isMoving = true; }

                // –í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å
                if (input.keys['Shift'] && isMoving && this.stamina > 0) {
                    this.stamina -= CONFIG.staminaDecayRun;
                    this.noiseLevel += 5;
                    gameState.globalNoise += 3;
                } else if (isMoving && this.stamina < CONFIG.maxStamina) {
                    this.noiseLevel += 2;
                    gameState.globalNoise += 1;
                    this.stamina = Math.min(this.stamina + CONFIG.staminaRecovery, CONFIG.maxStamina);
                } else if (this.stamina < CONFIG.maxStamina) {
                    this.stamina = Math.min(this.stamina + CONFIG.staminaRecovery, CONFIG.maxStamina);
                }

                this.noiseLevel = Math.max(0, this.noiseLevel - CONFIG.noiseDecay);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º spatial grid)
                const nearbyObjects = gameState.grid.getNearby(this.x, this.y, 150);
                for (let i = 0; i < nearbyObjects.obstacles.length; i++) {
                    const obs = nearbyObjects.obstacles[i];
                    const dx = obs.x - this.x;
                    const dy = obs.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = (this.radius + obs.radius) * (this.radius + obs.radius);

                    if (distSq < minDist && distSq > 0) {
                        // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–µ–º—Å—è –æ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                        const dist = Math.sqrt(distSq);
                        const push = (Math.sqrt(minDist) - dist) * 0.6;
                        this.x -= (dx / dist) * push;
                        this.y -= (dy / dist) * push;
                        this.vx *= 0.7;
                        this.vy *= 0.7;
                    }
                }

                // –ù–æ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –õ–Æ–ë–û–ô –º—ã—à–∏ (–µ—Å–ª–∏ –æ–Ω–∞ –≤—ã–±—Ä–∞–Ω–∞) —Ä—è–¥–æ–º —Å –Ω–µ–π
                let nearBurrow = false;
                for (let i = 0; i < gameState.burrows.length; i++) {
                    const burrow = gameState.burrows[i];
                    const dx = this.x - burrow.x;
                    const dy = this.y - burrow.y;
                    const distSq = dx * dx + dy * dy;
                    const burrowRange = (CONFIG.burrowRadius + this.radius) * (CONFIG.burrowRadius + this.radius);
                    if (distSq < burrowRange) {
                        nearBurrow = true;
                        // –í—ã–±—Ä–∞–Ω–Ω–∞—è –º—ã—à—å —Ä—è–¥–æ–º —Å –Ω–æ—Ä–∫–æ–π - –º–æ–∂–µ—Ç –≤–æ–π—Ç–∏ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ E
                        if (isSelected && input.keys['e'] && !this.inBurrow) {
                            this.inBurrow = true;
                            playSound('burrow');
                        }
                        break;
                    }
                }

                // –í—ã—Ö–æ–¥ –∏–∑ –Ω–æ—Ä–∫–∏ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –æ—Ç –Ω–µ—ë
                if (this.inBurrow && !nearBurrow) {
                    this.inBurrow = false;
                    this.burrowHealingTimer = 0;
                }

                if (this.inBurrow) {
                    this.burrowHealingTimer++;
                    if (this.burrowHealingTimer % 5 === 0) {
                        this.hp = Math.min(this.hp + CONFIG.healingSpeed, CONFIG.mouseMaxHP);
                    }
                } else {
                    this.burrowHealingTimer = 0;
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫—Ä—ã—Ç–∏—è
                this.hidden = false;
                const nearby = grid.getNearby(this.x, this.y, 100);
                for (let i = 0; i < nearby.obstacles.length; i++) {
                    const obs = nearby.obstacles[i];
                    const dx = this.x - obs.x;
                    const dy = this.y - obs.y;
                    if (dx * dx + dy * dy < (this.radius + obs.radius + 20) * (this.radius + obs.radius + 20)) {
                        this.hidden = true;
                        break;
                    }
                }

                // –ü–æ–∑–∏—Ü–∏—è
                this.x += this.vx;
                this.y += this.vy;

                // –ì—Ä–∞–Ω–∏—Ü—ã
                const padding = 30;
                if (this.x - this.radius < padding) this.x = this.radius + padding;
                if (this.x + this.radius > gameState.canvas.width - padding) this.x = gameState.canvas.width - this.radius - padding;
                if (this.y - this.radius < padding) this.y = this.radius + padding;
                if (this.y + this.radius > gameState.canvas.height - padding) this.y = gameState.canvas.height - this.radius - padding;

                // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –æ—Ç –¥—Ä—É–≥–∏—Ö –º—ã—à–µ–π
                for (let i = 0; i < gameState.mice.length; i++) {
                    const other = gameState.mice[i];
                    if (other === this || !other.alive) continue;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = (this.radius + other.radius) * 1.2;
                    if (distSq < minDist * minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const push = (minDist - dist) * 0.5;
                        this.x -= (dx / dist) * push;
                        this.y -= (dy / dist) * push;
                    }
                }

                // –°—ã—Ä
                for (let i = gameState.cheese.length - 1; i >= 0; i--) {
                    const cheese = gameState.cheese[i];
                    const dx = this.x - cheese.x;
                    const dy = this.y - cheese.y;
                    if (dx * dx + dy * dy < (this.radius + cheese.radius) * (this.radius + cheese.radius)) {
                        gameState.collectedCheese++;
                        gameState.score += (gameState.currentLevel * 10) + (this.stamina > 80 ? 20 : 5);
                        for (let j = 0; j < 8; j++) gameState.particles.get(cheese.x, cheese.y, 'üßÄ');
                        gameState.cheese.splice(i, 1);
                        playSound('cheese');
                    }
                }

                // –ö–æ—à–∫–∏ (–∑–∞—â–∏—Ç–∞ –≤ –Ω–æ—Ä–∫–µ!)
                if (!this.inBurrow) {
                    for (let i = 0; i < gameState.cats.length; i++) {
                        const cat = gameState.cats[i];
                        if (cat.canSee(this) || cat.canHear(this)) {
                            if (!cat.target) playSound('danger');
                            cat.target = this;
                        }
                        const dx = this.x - cat.x;
                        const dy = this.y - cat.y;
                        const distSq = dx * dx + dy * dy;
                        const catchDist = this.radius + cat.radius;
                        if (distSq < catchDist * catchDist) {
                            this.hp -= CONFIG.catDamage;
                            playSound('damage');
                            if (this.hp <= 0) {
                                this.alive = false;
                                for (let j = 0; j < 5; j++) gameState.particles.get(this.x, this.y, 'üíî');
                                playSound('caught');
                            }
                        }
                    }
                }

                // –ú—ã—à–µ–ª–æ–≤–∫–∏ (–∑–∞—â–∏—Ç–∞ –≤ –Ω–æ—Ä–∫–µ!)
                if (!this.inBurrow) {
                    for (let i = 0; i < gameState.traps.length; i++) {
                        const trap = gameState.traps[i];
                        const dx = this.x - trap.x;
                        const dy = this.y - trap.y;
                        if (dx * dx + dy * dy < (this.radius + trap.radius) * (this.radius + trap.radius)) {
                            this.alive = false;
                            for (let j = 0; j < 5; j++) gameState.particles.get(this.x, this.y, 'üí•');
                            playSound('trap');
                        }
                    }
                }
            }

            draw(ctx) {
                if (!this.alive) return;

                // –†–∏—Å—É–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–π –º—ã—à–∏ (–µ—Å–ª–∏ —ç—Ç–æ –æ–Ω–∞)
                if (gameState.selectedMouse === gameState.mice.indexOf(this)) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // HP –±–∞—Ä
                    ctx.save();
                    const barWidth = 50;
                    const barHeight = 5;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 25, barWidth, barHeight);
                    const hpRatio = this.hp / CONFIG.mouseMaxHP;
                    const barColor = hpRatio > 0.5 ? '#4CAF50' : hpRatio > 0.2 ? '#FFC107' : '#FF5722';
                    ctx.fillStyle = barColor;
                    ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 25, barWidth * hpRatio, barHeight);
                    ctx.restore();
                }

                // –ú—ã—à—å (—ç—Ñ—Ñ–µ–∫—Ç –ø—Ä—è—á–µ—Ç—Å—è –≤ –Ω–æ—Ä–∫–µ)
                ctx.save();
                let fontSize = this.radius * 2;
                let alpha = 1;

                if (this.inBurrow) {
                    // –ú—ã—à—å –≤ –Ω–æ—Ä–∫–µ - –º–µ–Ω—å—à–µ —Ä–∞–∑–º–µ—Ä –∏ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞
                    fontSize = this.radius * 1.4;
                    alpha = 0.6;
                    // –≠—Ñ—Ñ–µ–∫—Ç –º–µ—Ä—Ü–∞–Ω–∏—è –≤ –Ω–æ—Ä–∫–µ
                    const flicker = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                    alpha *= flicker;
                }

                ctx.globalAlpha = alpha;
                // –†–∏—Å—É–µ–º –º—ã—à—å —Ä–æ–∑–æ–≤—ã–º –∫—Ä—É–≥–æ–º - –≤–∏–¥–Ω–∞ –≤–µ–∑–¥–µ!
                drawCircle(ctx, this.x, this.y, this.radius * 0.8, '#FFB6C1');

                // –ï—Å–ª–∏ –≤ –Ω–æ—Ä–∫–µ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç "—É–∫—Ä—ã—Ç–∏—è"
                if (this.inBurrow) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = 'rgba(100, 150, 100, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Cat {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = CONFIG.catSize;
                this.emoji = 'üò∫';
                this.target = null;
                this.direction = Math.random() * Math.PI * 2;
                this.targetDirection = this.direction;
                this.patrolTimer = 0;
                this.chaseTimer = 0;
                this.alertLevel = 0;
                this.lastSeenPosition = null;
            }

            canSee(mouse) {
                if (!mouse.alive || mouse.hidden) return false;
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distSq = dx * dx + dy * dy;
                if (distSq > CONFIG.catVisionRange * CONFIG.catVisionRange) return false;

                const angleToMouse = Math.atan2(dy, dx);
                let angleDiff = Math.abs(this.direction - angleToMouse);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                return angleDiff < (CONFIG.catVisionAngle * Math.PI / 180 / 2);
            }

            canHear(mouse) {
                if (!mouse.alive) return false;
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                return dx * dx + dy * dy < CONFIG.catHearingRange * CONFIG.catHearingRange && mouse.noiseLevel > 15;
            }

            update(gameState) {
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;
                this.alertLevel = Math.max(0, this.alertLevel - 1);

                let angleDiff = this.targetDirection - this.direction;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                this.direction += angleDiff * 0.1;

                if (this.target && this.target.alive) {
                    this.chaseTimer++;
                    this.alertLevel = Math.min(this.alertLevel + 8, 100);
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distSq = dx * dx + dy * dy;

                    if (distSq > 25) {
                        const dist = Math.sqrt(distSq);
                        const chaseSpeed = CONFIG.catChaseSpeed + (this.alertLevel / 100) * 0.5;
                        this.vx += (dx / dist) * chaseSpeed;
                        this.vy += (dy / dist) * chaseSpeed;
                        this.targetDirection = Math.atan2(dy, dx);
                    }

                    if (!this.canSee(this.target) && !this.canHear(this.target)) {
                        this.chaseTimer++;
                        if (this.chaseTimer > 200) {
                            this.target = null;
                            this.chaseTimer = 0;
                            this.alertLevel = Math.max(0, this.alertLevel - 20);
                        }
                    }
                } else {
                    this.chaseTimer = 0;
                    if (this.lastSeenPosition) {
                        const dx = this.lastSeenPosition.x - this.x;
                        const dy = this.lastSeenPosition.y - this.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq > 400) {
                            const dist = Math.sqrt(distSq);
                            this.vx += (dx / dist) * CONFIG.catSpeed * 0.8;
                            this.vy += (dy / dist) * CONFIG.catSpeed * 0.8;
                            this.targetDirection = Math.atan2(dy, dx);
                        } else {
                            this.lastSeenPosition = null;
                        }
                    } else {
                        this.patrolTimer++;
                        if (this.patrolTimer > 80) {
                            this.targetDirection = Math.random() * Math.PI * 2;
                            this.patrolTimer = 0;
                        }
                        this.vx += Math.cos(this.targetDirection) * CONFIG.catSpeed * 0.3;
                        this.vy += Math.sin(this.targetDirection) * CONFIG.catSpeed * 0.3;
                    }
                }

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxSpeed = this.target ? 4.5 : 3.0;
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
                const nearbyObjects = gameState.grid.getNearby(this.x, this.y, 150);
                for (let i = 0; i < nearbyObjects.obstacles.length; i++) {
                    const obs = nearbyObjects.obstacles[i];
                    const dx = obs.x - this.x;
                    const dy = obs.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = (this.radius + obs.radius) * (this.radius + obs.radius);

                    if (distSq < minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const push = (Math.sqrt(minDist) - dist) * 0.6;
                        this.x -= (dx / dist) * push;
                        this.y -= (dy / dist) * push;
                        this.vx *= 0.7;
                        this.vy *= 0.7;
                    }
                }

                const padding = 30;
                if (this.x - this.radius < padding) {
                    this.x = this.radius + padding;
                    this.vx = 0;
                    this.targetDirection = Math.random() * Math.PI * 2;
                }
                if (this.x + this.radius > gameState.canvas.width - padding) {
                    this.x = gameState.canvas.width - this.radius - padding;
                    this.vx = 0;
                    this.targetDirection = Math.random() * Math.PI * 2;
                }
                if (this.y - this.radius < padding) {
                    this.y = this.radius + padding;
                    this.vy = 0;
                    this.targetDirection = Math.random() * Math.PI * 2;
                }
                if (this.y + this.radius > gameState.canvas.height - padding) {
                    this.y = gameState.canvas.height - this.radius - padding;
                    this.vy = 0;
                    this.targetDirection = Math.random() * Math.PI * 2;
                }
            }

            draw(ctx) {
                const halfAngle = CONFIG.catVisionAngle * Math.PI / 180 / 2;
                const intensity = 0.15 + (this.alertLevel / 100) * 0.35;

                // –†–∏—Å—É–µ–º –≤–∏–¥–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ
                ctx.save();
                ctx.fillStyle = `rgba(255, 50, 50, ${intensity * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.arc(this.x, this.y, CONFIG.catVisionRange, this.direction - halfAngle, this.direction + halfAngle);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                // –ö–æ—à–∫–∞ –í–°–ï–ì–î–ê –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–∏–¥–Ω–∞ - –æ—Ä–∞–Ω–∂–µ–≤—ã–π –∫—Ä—É–≥
                ctx.globalAlpha = 1; // –ö–†–ò–¢–ò–ß–ù–û: –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º 100% –≤–∏–¥–∏–º–æ—Å—Ç—å
                drawCircle(ctx, this.x, this.y, this.radius * 0.9, '#FF8C42');
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.obstacleSize;
                const emojis = ['ü™ë', 'üõèÔ∏è', 'üö™', 'ü™ü', 'üì∫', 'üåø', 'üõãÔ∏è', 'üè†', 'üöΩ', 'üöø', 'üì¶', 'ü™¥'];
                this.emoji = emojis[type % emojis.length];
            }

            draw(ctx) {
                ctx.globalAlpha = 1;
                // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è - —Ä–∏—Å—É–µ–º —ç–º–æ–¥–∑–∏ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
                drawEmoji(ctx, this.emoji, this.x, this.y, this.radius * 2);
            }
        }

        class Cheese {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.cheeseSize;
                this.emoji = 'üßÄ';
                this.bobbing = Math.random() * Math.PI * 2;
            }

            update() {
                this.bobbing += 0.05;
            }

            draw(ctx) {
                const bobOffset = Math.sin(this.bobbing) * 3;
                // –°—ã—Ä - –∂—ë–ª—Ç—ã–π –∫–≤–∞–¥—Ä–∞—Ç, –≤–∏–¥–Ω—ã –≤–µ–∑–¥–µ!
                drawSquare(ctx, this.x, this.y + bobOffset, this.radius * 2.4, '#FFD93D');
            }
        }

        class Burrow {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.burrowRadius;
                this.emoji = 'üï≥Ô∏è';
            }

            draw(ctx) {
                // –ù–æ—Ä–∫–∞ - –∫–æ—Ä–∏—á–Ω–µ–≤—ã–π –∫—Ä—É–≥, –≤–∏–¥–Ω–∞ –≤–µ–∑–¥–µ!
                drawCircle(ctx, this.x, this.y, this.radius * 0.85, '#8B4513');
            }
        }

        class Trap {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.cheeseSize;
                this.emoji = 'ü™§';
            }

            draw(ctx) {
                // –ú—ã—à–µ–ª–æ–≤–∫–∞ - –∫—Ä–∞—Å–Ω—ã–π —Ä–æ–º–±, –≤–∏–¥–Ω–∞ –≤–µ–∑–¥–µ!
                drawDiamond(ctx, this.x, this.y, this.radius * 2.4, '#DC143C');
            }
        }

        // ==================== –°–û–í–ï–¢–´ –ò –ü–û–î–°–ö–ê–ó–ö–ò ====================
        const TIPS = [
            "üí° –ü—Ä—è—á—å—Ç–µ—Å—å –∑–∞ –ø—Ä–µ–¥–º–µ—Ç—ã, —á—Ç–æ–±—ã –∫–æ—à–∫–∏ –≤–∞—Å –Ω–µ –≤–∏–¥–µ–ª–∏!",
            "üèÉ –°–ø—Ä–∏–Ω—Ç –∏–∑–¥–∞—ë—Ç –±–æ–ª—å—à–µ —à—É–º–∞ - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –µ–≥–æ –≤ –∫—Ä–∞–π–Ω–µ–º —Å–ª—É—á–∞–µ!",
            "üï≥Ô∏è –ù–æ—Ä–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç –∑–¥–æ—Ä–æ–≤—å–µ - —Å–ø–∞—Å–∞–π—Ç–µ—Å—å –≤ –Ω–∏—Ö!",
            "üëÇ –ö–æ—à–∫–∏ —Å–ª—ã—à–∞—Ç –≥—Ä–æ–º–∫–∏–π —à—É–º - —Ö–æ–¥–∏—Ç–µ —Ç–∏—Ö–æ!",
            "üßÄ –°–æ–±–∏—Ä–∞–π—Ç–µ —Å—ã—Ä –±—ã—Å—Ç—Ä–æ, –Ω–æ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ - –∫–æ–º–±–æ –¥–∞—ë—Ç –±–æ–Ω—É—Å!",
            "‚≠ê –°–æ–±–µ—Ä–∏—Ç–µ –≤–µ—Å—å —Å—ã—Ä –∏ –¥–æ–π–¥–∏—Ç–µ –¥–æ –∫–æ–Ω—Ü–∞ —É—Ä–æ–≤–Ω—è!",
            "üéØ –ö–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–µ–µ - –±—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–µ–µ!",
            "üê± –ö–æ—à–∫–∏ –≤–∏–¥—è—Ç –≤ –∫–æ–Ω—É—Å–µ –≤–ø–µ—Ä–µ–¥–∏ —Å–µ–±—è - –æ–±—Ö–æ–¥–∏—Ç–µ –∏—Ö —Å–±–æ–∫—É!",
            "‚ö° –í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –º–µ–¥–ª–µ–Ω–Ω–µ–µ –ø—Ä–∏ –±–æ–ª—å—à–æ–º —à—É–º–µ!",
            "üéÆ TAB –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –º—ã—à–µ–π - –≤—ã–±–∏—Ä–∞–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏!"
        ];

        let currentTip = 0;
        function getNextTip() {
            const tip = TIPS[currentTip % TIPS.length];
            currentTip++;
            return tip;
        }

        function displayTip() {
            const tipElement = document.getElementById('menuTip');
            if (tipElement) {
                tipElement.textContent = getNextTip();
            }
        }

        function rotateTip() {
            const tipElement = document.getElementById('menuTip');
            if (tipElement) {
                tipElement.style.animation = 'none';
                setTimeout(() => {
                    tipElement.style.animation = 'tipFade 0.5s ease-in';
                    tipElement.textContent = getNextTip();
                }, 10);
            }
        }

        // ==================== –†–ï–ô–¢–ò–ù–ì –ò –õ–ò–î–ï–†–ë–û–†–î ====================
        function getLeaderboard() {
            const data = localStorage.getItem('mouseGameLeaderboard');
            return data ? JSON.parse(data) : [];
        }

        function saveLeaderboard(leaderboard) {
            localStorage.setItem('mouseGameLeaderboard', JSON.stringify(leaderboard));
        }

        function addScore(playerName, score, level) {
            if (!playerName.trim()) return;

            const leaderboard = getLeaderboard();
            leaderboard.push({
                name: playerName.trim(),
                score: score,
                level: level,
                date: new Date().toLocaleDateString('ru-RU')
            });

            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –æ—á–∫–∞–º (–±–æ–ª—å—à–µ = –ª—É—á—à–µ)
            leaderboard.sort((a, b) => b.score - a.score);

            // –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ —Ç–æ–ø 10
            const top10 = leaderboard.slice(0, 10);
            saveLeaderboard(top10);
        }

        function displayLeaderboard() {
            const leaderboard = getLeaderboard();
            const content = document.getElementById('leaderboardContent');

            if (leaderboard.length === 0) {
                content.innerHTML = '<p style="text-align: center; opacity: 0.7;">–†–µ–π—Ç–∏–Ω–≥ –ø—É—Å—Ç. –ë—É–¥—å –ø–µ—Ä–≤—ã–º! üéØ</p>';
                return;
            }

            let html = '<div style="font-family: monospace;">';
            leaderboard.forEach((entry, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                html += `<div style="
                    display: flex;
                    justify-content: space-between;
                    padding: 10px;
                    margin: 5px 0;
                    background: rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    border-left: 3px solid #FFD93D;
                ">
                    <span>${medal} ${entry.name}</span>
                    <span style="color: #FFD93D; font-weight: bold;">${entry.score} ‚≠ê</span>
                </div>`;
            });
            html += '</div>';
            content.innerHTML = html;
        }

        function showLeaderboard() {
            playSound('button');
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('leaderboardScreen').style.display = 'flex';
            displayLeaderboard();
        }

        function hideLeaderboard() {
            playSound('button');
            document.getElementById('leaderboardScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function saveScore() {
            const playerName = document.getElementById('playerName').value;
            if (playerName.trim()) {
                playSound('button');
                addScore(playerName, gameState.score, gameState.currentLevel);
                skipScoreSave();
            }
        }

        function skipScoreSave() {
            playSound('button');
            document.getElementById('scoreInputPanel').style.display = 'none';
            document.getElementById('playerName').value = '';
        }

        // –£–î–ê–õ–ï–ù–û: displayGameStats() - –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–∞, HTML —Å—Ç—Ä–æ–∏—Ç—Å—è –ø—Ä—è–º–æ –≤ game loop
        // –§—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∑–∞–≤–∏—Å–∞–Ω–∏—è —á–µ—Ä–µ–∑ setTimeout

        // ==================== –°–û–°–¢–û–Ø–ù–ò–ï ====================
        let gameState = {
            isRunning: false,
            isPaused: false,
            currentLevel: 1,
            score: 0,
            mice: [],
            cats: [],
            cheese: [],
            obstacles: [],
            particles: null,
            burrows: [],
            traps: [],
            canvas: null,
            ctx: null,
            selectedMouse: 0,
            allCheese: 0,
            collectedCheese: 0,
            globalNoise: 0,
            backgroundGradient: null,
            audioContext: null,
            grid: null,
            fps: 60,
        };

        let input = { keys: {}, mouse: { x: 0, y: 0 } };
        let fpsFrames = 0, lastFpsTime = 0;

        // ==================== –ó–í–£–ö–ò ====================
        function initAudio() {
            if (!gameState.audioContext) {
                try {
                    // Safari, Chrome, Firefox compatibility
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
                    if (!AudioContextClass) {
                        console.log('Web Audio API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                        return null;
                    }
                    gameState.audioContext = new AudioContextClass();

                    // Resume audio context for iOS/Safari
                    if (gameState.audioContext.state === 'suspended') {
                        document.addEventListener('click', () => {
                            gameState.audioContext.resume();
                        }, { once: true });
                    }
                } catch (e) {
                    console.log('Audio –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω:', e.message);
                    return null;
                }
            }
            return gameState.audioContext;
        }

        function playSound(type) {
            const ctx = initAudio();
            if (!ctx) return;

            try {
                switch (type) {
                    // ========== –°–´–†–ê - –≤–µ—Å—ë–ª—ã–π –≤—ã—Å–æ–∫–∏–π –∑–≤—É–∫ ==========
                    case 'cheese': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 950;
                        gain.gain.setValueAtTime(0.25, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.15);
                        break;
                    }

                    // ========== –£–†–û–ù –û–¢ –ö–û–¢–ê - —Ç—Ä–µ–≤–æ–∂–Ω—ã–π —Å–∫—Ä–∏–ø ==========
                    case 'damage': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(600, ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(350, ctx.currentTime + 0.15);
                        gain.gain.setValueAtTime(0.3, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.15);
                        break;
                    }

                    // ========== –û–ü–ê–°–ù–û–°–¢–¨ (–∫–æ—Ç —Å–ª—ã—à–∏—Ç) - –±—ã—Å—Ç—Ä—ã–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—é—â–∏–µ –∑–≤—É–∫–∏ ==========
                    case 'danger': {
                        for (let i = 0; i < 2; i++) {
                            setTimeout(() => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();
                                osc.connect(gain);
                                gain.connect(ctx.destination);
                                osc.frequency.value = 700 + (i * 100);
                                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                                osc.start(ctx.currentTime);
                                osc.stop(ctx.currentTime + 0.08);
                            }, i * 100);
                        }
                        break;
                    }

                    // ========== –ü–†–Ø–¢–ö–ê –í –ù–û–†–ö–ï - —Å–ø–æ–∫–æ–π–Ω—ã–π, —É—é—Ç–Ω—ã–π –∑–≤—É–∫ ==========
                    case 'burrow': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(300, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(400, ctx.currentTime + 0.3);
                        gain.gain.setValueAtTime(0.15, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.02, ctx.currentTime + 0.3);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.3);
                        break;
                    }

                    // ========== –ö–õ–ò–ö –ö–ù–û–ü–ö–ò - –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–π —â–µ–ª—á–æ–∫ ==========
                    case 'button': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 550;
                        gain.gain.setValueAtTime(0.2, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.12);
                        break;
                    }

                    // ========== –ú–´–®–ï–õ–û–í–ö–ê - –æ–ø–∞—Å–Ω—ã–π –∑–≤—É–∫ ==========
                    case 'trap': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(200, ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.2);
                        gain.gain.setValueAtTime(0.35, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.2);
                        break;
                    }

                    // ========== –ü–ê–£–ó–ê - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —â–µ–ª—á–æ–∫ ==========
                    case 'pause': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 450;
                        gain.gain.setValueAtTime(0.15, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.1);
                        break;
                    }

                    // ========== –ú–ï–ù–Æ - –º—è–≥–∫–∏–π –∑–≤—É–∫ –æ—Ç–∫—Ä—ã—Ç–∏—è ==========
                    case 'menu': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(350, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(500, ctx.currentTime + 0.25);
                        gain.gain.setValueAtTime(0.12, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.25);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.25);
                        break;
                    }

                    // ========== –ö–û–ù–ï–¶ –£–†–û–í–ù–Ø - —ç–ø–∏—á–µ—Å–∫–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ ==========
                    case 'level': {
                        const notes = [400, 500, 600, 700];
                        for (let i = 0; i < notes.length; i++) {
                            setTimeout(() => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();
                                osc.connect(gain);
                                gain.connect(ctx.destination);
                                osc.frequency.value = notes[i];
                                gain.gain.setValueAtTime(0.12, ctx.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                                osc.start(ctx.currentTime);
                                osc.stop(ctx.currentTime + 0.12);
                            }, i * 80);
                        }
                        break;
                    }

                    // ========== –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê - –≥—Ä—É—Å—Ç–Ω—ã–π –∑–≤—É–∫ ==========
                    case 'gameOver': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(500, ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.5);
                        gain.gain.setValueAtTime(0.25, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.5);
                        break;
                    }

                    // ========== –ü–û–ë–ï–î–ê - –ø—Ä–∞–∑–¥–Ω–∏—á–Ω—ã–π –∑–≤—É–∫ ==========
                    case 'victory': {
                        const notes = [600, 700, 800, 900];
                        for (let i = 0; i < notes.length; i++) {
                            setTimeout(() => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();
                                osc.connect(gain);
                                gain.connect(ctx.destination);
                                osc.frequency.value = notes[i];
                                gain.gain.setValueAtTime(0.15, ctx.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                                osc.start(ctx.currentTime);
                                osc.stop(ctx.currentTime + 0.2);
                            }, i * 120);
                        }
                        break;
                    }

                    // ========== –ü–û–ü–ê–î–ê–ù–ò–ï –í –ö–û–ì–¢–ò (–ø–æ–π–º–∞–Ω–∞) - –≥—Ä–æ–º–∫–∏–π —É–¥–∞—Ä ==========
                    case 'caught': {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.setValueAtTime(250, ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.3);
                        gain.gain.setValueAtTime(0.4, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + 0.3);
                        break;
                    }
                }
            } catch (e) {}
        }

        // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
        function initGame() {
            console.log(`üìç initGame() - Level ${gameState.currentLevel}`);
            try {
                // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                gameLoopSafetyCounter = 0;

                gameState.canvas = document.getElementById('gameCanvas');
                if (!gameState.canvas) throw new Error('Canvas not found!');
                console.log('‚úÖ Canvas –Ω–∞–π–¥–µ–Ω');

                gameState.ctx = gameState.canvas.getContext('2d');
                if (!gameState.ctx) throw new Error('Canvas context failed!');
                console.log('‚úÖ Context –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');

                const levelConfig = getLevelConfig(gameState.currentLevel);
                console.log(`‚úÖ Level config –∑–∞–≥—Ä—É–∂–µ–Ω–∞: ${levelConfig.mice}–º, ${levelConfig.cats}–∫, ${levelConfig.cheese}—á`);

                // Responsive canvas sizing - use optimal size but respect level requirements
                const optimalSize = getOptimalCanvasSize();
                const canvasWidth = Math.min(levelConfig.roomWidth, optimalSize.width);
                const canvasHeight = Math.min(levelConfig.roomHeight, optimalSize.height);

                gameState.canvas.width = canvasWidth;
                gameState.canvas.height = canvasHeight;
                console.log(`‚úÖ Canvas —Ä–∞–∑–º–µ—Ä: ${canvasWidth}x${canvasHeight}`);

                gameState.grid = new SpatialGrid(levelConfig.roomWidth, levelConfig.roomHeight, 100);
            gameState.particles = new ParticlePool(500);

            gameState.backgroundGradient = gameState.ctx.createLinearGradient(0, 0, gameState.canvas.width, gameState.canvas.height);
            gameState.backgroundGradient.addColorStop(0, '#FFE66D');
            gameState.backgroundGradient.addColorStop(0.5, '#F4F4F4');
            gameState.backgroundGradient.addColorStop(1, '#A8E6CF');

            gameState.mice = [];
            gameState.cats = [];
            gameState.cheese = [];
            gameState.obstacles = [];
            gameState.burrows = [];
            gameState.traps = [];
            gameState.collectedCheese = 0;
            gameState.allCheese = levelConfig.cheese;
            gameState.selectedMouse = 0;
            gameState.globalNoise = 0;

            // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
            for (let i = 0; i < levelConfig.obstacles; i++) {
                let x, y, valid;
                do {
                    valid = true;
                    x = 100 + Math.random() * (levelConfig.roomWidth - 200);
                    y = 100 + Math.random() * (levelConfig.roomHeight - 200);

                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obs = gameState.obstacles[j];
                        const dx = obs.x - x;
                        const dy = obs.y - y;
                        if (dx * dx + dy * dy < 120 * 120) {
                            valid = false;
                            break;
                        }
                    }
                } while (!valid);
                const obs = new Obstacle(x, y, i);
                gameState.obstacles.push(obs);
                gameState.grid.insert('obstacles', x, y, obs);
            }

            // –ù–æ—Ä–∫–∏
            for (let i = 0; i < levelConfig.burrows; i++) {
                let x, y, valid;
                do {
                    valid = true;
                    x = 100 + Math.random() * (levelConfig.roomWidth - 200);
                    y = 100 + Math.random() * (levelConfig.roomHeight - 200);

                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obs = gameState.obstacles[j];
                        const dx = obs.x - x;
                        const dy = obs.y - y;
                        if (dx * dx + dy * dy < 120 * 120) {
                            valid = false;
                            break;
                        }
                    }
                    for (let j = 0; j < gameState.burrows.length; j++) {
                        const burrow = gameState.burrows[j];
                        const dx = burrow.x - x;
                        const dy = burrow.y - y;
                        if (dx * dx + dy * dy < 120 * 120) {
                            valid = false;
                            break;
                        }
                    }
                } while (!valid);
                gameState.burrows.push(new Burrow(x, y));
            }

            // –ú—ã—à–µ–ª–æ–≤–∫–∏
            for (let i = 0; i < levelConfig.traps; i++) {
                let x, y, valid;
                do {
                    valid = true;
                    x = 100 + Math.random() * (levelConfig.roomWidth - 200);
                    y = 100 + Math.random() * (levelConfig.roomHeight - 200);

                    // –ù–µ —Å–ø–∞—É–Ω–∏–º –Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è—Ö
                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obs = gameState.obstacles[j];
                        const dx = obs.x - x;
                        const dy = obs.y - y;
                        if (dx * dx + dy * dy < 100 * 100) {
                            valid = false;
                            break;
                        }
                    }

                    // –ù–µ —Å–ø–∞—É–Ω–∏–º –Ω–∞ –Ω–æ—Ä–∫–∞—Ö
                    for (let j = 0; j < gameState.burrows.length; j++) {
                        const burrow = gameState.burrows[j];
                        const dx = burrow.x - x;
                        const dy = burrow.y - y;
                        if (dx * dx + dy * dy < 120 * 120) {
                            valid = false;
                            break;
                        }
                    }

                    // –ù–µ —Å–ø–∞—É–Ω–∏–º –Ω–∞ –¥—Ä—É–≥–∏—Ö –º—ã—à–µ–ª–æ–≤–∫–∞—Ö
                    for (let j = 0; j < gameState.traps.length; j++) {
                        const trap = gameState.traps[j];
                        const dx = trap.x - x;
                        const dy = trap.y - y;
                        if (dx * dx + dy * dy < 100 * 100) {
                            valid = false;
                            break;
                        }
                    }
                } while (!valid);
                gameState.traps.push(new Trap(x, y));
            }

            // –ú—ã—à–∏
            for (let i = 0; i < levelConfig.mice; i++) {
                gameState.mice.push(new Mouse(120 + i * 80, 120 + i * 80));
            }

            // –ö–æ—à–∫–∏
            for (let i = 0; i < levelConfig.cats; i++) {
                gameState.cats.push(new Cat(
                    levelConfig.roomWidth - 120 - i * 80,
                    levelConfig.roomHeight - 120 - i * 80
                ));
            }

            // –°—ã—Ä
            for (let i = 0; i < levelConfig.cheese; i++) {
                let x, y, valid;
                do {
                    valid = true;
                    x = 100 + Math.random() * (levelConfig.roomWidth - 200);
                    y = 100 + Math.random() * (levelConfig.roomHeight - 200);

                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obs = gameState.obstacles[j];
                        const dx = obs.x - x;
                        const dy = obs.y - y;
                        if (dx * dx + dy * dy < 100 * 100) {
                            valid = false;
                            break;
                        }
                    }
                    for (let j = 0; j < gameState.traps.length; j++) {
                        const trap = gameState.traps[j];
                        const dx = trap.x - x;
                        const dy = trap.y - y;
                        if (dx * dx + dy * dy < 80 * 80) {
                            valid = false;
                            break;
                        }
                    }
                } while (!valid);
                gameState.cheese.push(new Cheese(x, y));
            }

                console.log(`‚úÖ initGame –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${gameState.mice.length}–º, ${gameState.cats.length}–∫, ${gameState.cheese.length}—á`);
            } catch (e) {
                console.error('‚ùå ERROR in initGame:', e.message);
                console.error(e.stack);
                alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã!\n' + e.message);
                gameState.isRunning = false;
                return;
            }

            updateUI();
            playSound('level');
        }

        // ==================== UI ====================
        function updateUI() {
            // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º UI –µ—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞
            if (!gameState.isRunning) return;

            try {
                // –ë—ã—Å—Ç—Ä–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –º—ã—à–∏
                if (gameState.mice.length === 0) return;

                let aliveCount = 0;
                let mainHP = 0;

                // –ë—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –±–µ–∑ –∏–∑–ª–∏—à–Ω–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
                const selectedIdx = gameState.selectedMouse;
                for (let i = 0; i < gameState.mice.length; i++) {
                    const m = gameState.mice[i];
                    if (m.alive) aliveCount++;
                    if (i === selectedIdx) mainHP = m.hp;
                }

                // –ö—ç—à–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —á—Ç–æ–±—ã –Ω–µ –∏—Å–∫–∞—Ç—å –∏—Ö –∫–∞–∂–¥—ã–π —Ä–∞–∑
                const miceCountEl = document.getElementById('miceCount');
                const miceHPEl = document.getElementById('miceHP');
                const cheeseCountEl = document.getElementById('cheeseCount');
                const totalCheeseEl = document.getElementById('totalCheese');
                const levelNumberEl = document.getElementById('levelNumber');
                const staminaEl = document.getElementById('stamina');
                const fpsEl = document.getElementById('fps');

                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —Å—É—â–µ—Å—Ç–≤—É—é—Ç
                if (miceCountEl) miceCountEl.textContent = aliveCount;
                if (miceHPEl) miceHPEl.textContent = Math.round(mainHP);
                if (cheeseCountEl) cheeseCountEl.textContent = gameState.collectedCheese;
                if (totalCheeseEl) totalCheeseEl.textContent = gameState.allCheese;
                if (levelNumberEl) levelNumberEl.textContent = gameState.currentLevel;

                // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å–æ stamina
                const selectedMouse = gameState.mice[selectedIdx];
                if (staminaEl && selectedMouse) {
                    staminaEl.textContent = Math.round(selectedMouse.stamina || 0);
                }

                if (fpsEl) fpsEl.textContent = gameState.fps || 0;
            } catch (e) {
                console.log('updateUI –æ—à–∏–±–∫–∞ (–Ω–µ–∫—Ä–∏—Ç–∏—á–Ω–∞):', e);
                // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º game loop –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ –≤ UI
            }
        }

        // ==================== –ì–õ–ê–í–ù–û–ô –¶–ò–ö–õ ====================
        let lastGameOverTime = 0;
        let gameLoopSafetyCounter = 0;

        function gameLoop() {
            if (!gameState.isRunning) return;

            // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä
            if (gameLoopSafetyCounter === 0) {
                console.log('‚ñ∂Ô∏è gameLoop STARTED! –ü–µ—Ä–≤—ã–π –∫–∞–¥—Ä –æ—Ç—Ä–∏—Å–æ–≤–∫–∏');
            }

            if (gameState.isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // –ó–∞—â–∏—Ç–∞ –æ—Ç infinite loop
            gameLoopSafetyCounter++;
            if (gameLoopSafetyCounter > 100000) {
                console.error('–ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨: –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π infinite loop');
                gameState.isRunning = false;
                return;
            }

            try {
                const now = performance.now();
                fpsFrames++;
                if (now - lastFpsTime >= 1000) {
                    gameState.fps = fpsFrames;
                    fpsFrames = 0;
                    lastFpsTime = now;
                }

                gameState.ctx.fillStyle = gameState.backgroundGradient;
                gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);

                // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä
                if (gameLoopSafetyCounter === 1) {
                    console.log(`üé® Canvas rendering: ${gameState.canvas.width}x${gameState.canvas.height}`);
                    console.log(`üéÆ Game objects:${gameState.mice.length}–º, ${gameState.cats.length}–∫, ${gameState.cheese.length}—á, ${gameState.obstacles.length}–ø—Ä`);
                }

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏—è
                for (let i = gameState.mice.length - 1; i >= 0; i--) {
                    gameState.mice[i].update(gameState.grid, input, gameState);
                }
                for (let i = gameState.cats.length - 1; i >= 0; i--) {
                    gameState.cats[i].update(gameState);
                }
                for (let i = gameState.cheese.length - 1; i >= 0; i--) {
                    gameState.cheese[i].update();
                }
                gameState.particles.update();

                gameState.globalNoise = Math.max(0, gameState.globalNoise - 0.8);

                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
                for (let i = 0; i < gameState.obstacles.length; i++) {
                    gameState.obstacles[i].draw(gameState.ctx);
                }
                for (let i = 0; i < gameState.burrows.length; i++) {
                    gameState.burrows[i].draw(gameState.ctx);
                }
                for (let i = 0; i < gameState.traps.length; i++) {
                    gameState.traps[i].draw(gameState.ctx);
                }
                for (let i = 0; i < gameState.cheese.length; i++) {
                    gameState.cheese[i].draw(gameState.ctx);
                }
                for (let i = 0; i < gameState.cats.length; i++) {
                    gameState.cats[i].draw(gameState.ctx);
                }
                for (let i = 0; i < gameState.mice.length; i++) {
                    gameState.mice[i].draw(gameState.ctx);
                }

                gameState.particles.draw(gameState.ctx);

                // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ì–ê–†–ê–ù–¢–ò–Ø: globalAlpha –≤—Å–µ–≥–¥–∞ = 1 –≤ –∫–æ–Ω—Ü–µ –∫–∞–¥—Ä–∞
                gameState.ctx.globalAlpha = 1;
                gameState.ctx.fillStyle = '#000';

                updateUI();

                // –ü—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π - –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –∏–≥—Ä–∞ –≤—Å–µ –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
                if (!gameState.isRunning) {
                    // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –∑–∞—â–∏—Ç–∞: –µ—Å–ª–∏ isRunning —Å—Ç–∞–ª false, –≤—ã—Ö–æ–¥–∏–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
                    gameLoopSafetyCounter = 0;
                    return;
                }

                let aliveMice = 0;
                for (let i = 0; i < gameState.mice.length; i++) {
                    if (gameState.mice[i].alive) aliveMice++;
                }

                if (aliveMice === 0) {
                    // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º —Ü–∏–∫–ª
                    gameState.isRunning = false;
                    gameLoopSafetyCounter = 0;
                    playSound('gameOver');

                    // –û—á–∏—â–∞–µ–º input state —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–≤–∏—Å–∞–Ω–∏—è
                    input.keys = {};

                    // –°–æ–∑–¥–∞–µ–º —Å–Ω–∏–º–æ–∫ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã –î–û –ª—é–±—ã—Ö DOM –æ–ø–µ—Ä–∞—Ü–∏–π
                    const finalLevel = gameState.currentLevel;
                    const finalCheese = gameState.collectedCheese;
                    const finalAllCheese = gameState.allCheese;
                    const finalScore = gameState.score;

                    // –ù–ï –∏—Å–ø–æ–ª—å–∑—É–µ–º setTimeout - –æ–Ω –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã
                    // –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω game over —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
                    try {
                        const textEl = document.getElementById('gameOverText');
                        if (textEl) {
                            textEl.textContent = `–£—Ä–æ–≤–µ–Ω—å: ${finalLevel}\n–°—ã—Ä —Å–æ–±—Ä–∞–Ω: ${finalCheese}/${finalAllCheese}\n–û—á–∫–∏: ${finalScore}`;
                        }

                        const statsPanel = document.getElementById('statsPanel');
                        if (statsPanel) {
                            // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±—ã—Å—Ç—Ä–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ HTML
                            statsPanel.innerHTML = `
                                <div style="background:rgba(255,255,255,0.1);padding:15px;border-radius:10px;text-align:center;border:1px solid rgba(255,255,255,0.2);">
                                    <div style="font-size:28px;margin-bottom:5px;">üê≠</div>
                                    <div style="font-size:12px;opacity:0.7;">–ú—ã—à–∏ —Å–ø–∞—Å–µ–Ω—ã</div>
                                    <div style="font-size:24px;font-weight:bold;color:#FFD93D;">${aliveMice}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.1);padding:15px;border-radius:10px;text-align:center;border:1px solid rgba(255,255,255,0.2);">
                                    <div style="font-size:28px;margin-bottom:5px;">üßÄ</div>
                                    <div style="font-size:12px;opacity:0.7;">–°—ã—Ä —Å–æ–±—Ä–∞–Ω</div>
                                    <div style="font-size:24px;font-weight:bold;color:#FFD93D;">${finalCheese}/${finalAllCheese}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.1);padding:15px;border-radius:10px;text-align:center;border:1px solid rgba(255,255,255,0.2);">
                                    <div style="font-size:28px;margin-bottom:5px;">‚≠ê</div>
                                    <div style="font-size:12px;opacity:0.7;">–û—á–∫–∏</div>
                                    <div style="font-size:24px;font-weight:bold;color:#FFD93D;">${finalScore}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.1);padding:15px;border-radius:10px;text-align:center;border:1px solid rgba(255,255,255,0.2);">
                                    <div style="font-size:28px;margin-bottom:5px;">üìä</div>
                                    <div style="font-size:12px;opacity:0.7;">–£—Ä–æ–≤–µ–Ω—å</div>
                                    <div style="font-size:24px;font-weight:bold;color:#FFD93D;">${finalLevel}</div>
                                </div>
                            `;
                        }

                        const inputPanel = document.getElementById('scoreInputPanel');
                        if (inputPanel) inputPanel.style.display = 'block';

                        const playerNameEl = document.getElementById('playerName');
                        if (playerNameEl) playerNameEl.focus();

                        const gameOverScreen = document.getElementById('gameOverScreen');
                        if (gameOverScreen) gameOverScreen.classList.add('active');
                    } catch (e) {
                        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ game over:', e);
                    }

                    // –ü–û–õ–ù–ê–Ø –ì–ê–†–ê–ù–¢–ò–Ø: –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º game loop
                    return;
                }

                if (gameState.cheese.length === 0 && gameState.allCheese > 0) {
                    // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º —Ü–∏–∫–ª
                    gameState.isRunning = false;
                    gameLoopSafetyCounter = 0;
                    playSound('victory');

                    // –û—á–∏—â–∞–µ–º input state
                    input.keys = {};

                    // –°–æ–∑–¥–∞–µ–º —Å–Ω–∏–º–æ–∫ —Å–æ—Å—Ç–æ—è–Ω–∏—è –î–û –ª—é–±—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
                    const completeLevel = gameState.currentLevel;
                    const completeAliveMice = aliveMice;
                    const bonusPoints = aliveMice * 100;
                    const completeFinalScore = gameState.score + gameState.allCheese * (completeLevel * 10) + bonusPoints;

                    // –û–±–Ω–æ–≤–ª—è–µ–º score –≤ gameState
                    gameState.score = completeFinalScore;

                    // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω
                    try {
                        const textEl = document.getElementById('levelCompleteText');
                        if (textEl) {
                            textEl.textContent = `üéâ –£—Ä–æ–≤–µ–Ω—å ${completeLevel} –ø—Ä–æ–π–¥–µ–Ω!\n–ú—ã—à–∏ —Å–ø–∞—Å–µ–Ω—ã: ${completeAliveMice}\n–û—á–∫–∏: ${completeFinalScore}`;
                        }
                        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
                        if (levelCompleteScreen) levelCompleteScreen.classList.add('active');
                    } catch (e) {
                        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ level complete:', e);
                    }

                    // –ü–û–õ–ù–ê–Ø –ì–ê–†–ê–ù–¢–ò–Ø: –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º game loop
                    return;
                }

                // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –Ω–∞ –∫–∞–∂–¥—ã–π —É—Å–ø–µ—à–Ω—ã–π —Ü–∏–∫–ª
                gameLoopSafetyCounter = 0;
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error('–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ gameLoop:', e);
                gameState.isRunning = false;
                gameLoopSafetyCounter = 0;
                // –ü—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
                setTimeout(() => {
                    if (!gameState.isRunning) {
                        console.log('–ò–≥—Ä–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏');
                    }
                }, 100);
            }
        }

        // ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï ====================
        // Touch controls for mobile
        function setupTouchControls() {
            const virtualControls = document.getElementById('virtualControls');
            if (!virtualControls) return;

            const buttons = virtualControls.querySelectorAll('.control-btn');
            buttons.forEach(btn => {
                const key = btn.dataset.key;

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    input.keys[key] = true;
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    input.keys[key] = false;
                }, { passive: false });

                btn.addEventListener('mousedown', () => {
                    input.keys[key] = true;
                });

                btn.addEventListener('mouseup', () => {
                    input.keys[key] = false;
                });

                btn.addEventListener('mouseleave', () => {
                    input.keys[key] = false;
                });
            });
        }

        // Handle device orientation changes
        function handleOrientationChange() {
            const newOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
            if (newOrientation !== lastOrientationCheck && gameState.isRunning) {
                lastOrientationCheck = newOrientation;
                // Re-initialize game with new canvas size
                initGame();
            }
        }

        // Orientation and resize events
        window.addEventListener('orientationchange', handleOrientationChange, false);
        window.addEventListener('resize', handleOrientationChange, false);

        // Prevent default touch behaviors for better mobile experience
        document.addEventListener('touchmove', (e) => {
            if (e.target === gameState.canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–ª—é—á (Shift, Enter, Space) –∏ lowercase –≤–µ—Ä—Å–∏—é –¥–ª—è –±—É–∫–≤
            const keyName = e.key === ' ' ? 'Space' : (e.key === 'Enter' ? 'Enter' : (e.key === 'Shift' ? 'Shift' : e.key.toLowerCase()));
            input.keys[keyName] = true;

            if (e.key === ' ') {
                e.preventDefault();
                if (gameState.isRunning) {
                    gameState.isPaused = !gameState.isPaused;
                    document.getElementById('pauseScreen').classList.toggle('active');
                    playSound('pause');
                }
            }

            if (e.key === 'Tab') {
                e.preventDefault();
                if (gameState.isRunning && !gameState.isPaused && gameState.mice.length > 1) {
                    gameState.selectedMouse = (gameState.selectedMouse + 1) % gameState.mice.length;
                    let iterations = 0;
                    while (!gameState.mice[gameState.selectedMouse].alive && iterations < gameState.mice.length) {
                        gameState.selectedMouse = (gameState.selectedMouse + 1) % gameState.mice.length;
                        iterations++;
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const keyName = e.key === ' ' ? 'Space' : (e.key === 'Enter' ? 'Enter' : (e.key === 'Shift' ? 'Shift' : e.key.toLowerCase()));
            input.keys[keyName] = false;
        });

        // ==================== –°–¢–ê–†–¢–ï–† ====================
        function startGame() {
            console.log('üéÆ START GAME - –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã...');
            try {
                document.getElementById('menuScreen').classList.remove('active');
                document.getElementById('pauseScreen').classList.remove('active');
                document.getElementById('levelCompleteScreen').classList.remove('active');
                document.getElementById('gameOverScreen').classList.remove('active');
                gameState.currentLevel = 1;
                gameState.score = 0;
                gameState.isRunning = true;
                gameState.isPaused = false;
                console.log('üéÆ –ú–µ–Ω—é —Å–∫—Ä—ã—Ç–æ, —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
                playSound('button');
                console.log('üéÆ –í—ã–∑–æ–≤ initGame()...');
                initGame();
                console.log('üéÆ initGame() –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –≤—ã–∑–æ–≤ gameLoop()...');
                gameLoop();
                console.log('‚úÖ Game started —É—Å–ø–µ—à–Ω–æ!');
            } catch (e) {
                console.error('‚ùå ERROR in startGame:', e.message, e.stack);
            }
        }

        function nextLevel() {
            document.getElementById('levelCompleteScreen').classList.remove('active');
            gameState.currentLevel++;
            gameState.isRunning = true;
            gameState.isPaused = false;
            playSound('button');
            initGame();
            gameLoop();
        }

        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseScreen').classList.remove('active');
            playSound('pause');
        }

        function menuGame() {
            gameState.isRunning = false;
            playSound('menu');
            document.getElementById('menuScreen').classList.add('active');
            document.getElementById('pauseScreen').classList.remove('active');
            document.getElementById('levelCompleteScreen').classList.remove('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('leaderboardScreen').style.display = 'none';
            document.getElementById('scoreInputPanel').style.display = 'none';
            document.getElementById('playerName').value = '';
        }

        window.addEventListener('load', () => {
            // Update version display
            const versionDisplay = document.getElementById('versionDisplay');
            if (versionDisplay) {
                versionDisplay.textContent = GAME_VERSION;
            }

            console.log('üê≠ –ò–≥—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞!');
            console.log(`üìå –í–µ—Ä—Å–∏—è: ${GAME_VERSION}`);
            console.log('‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞');
            console.log('‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤–∫–ª—é—á–µ–Ω–æ');
            console.log('‚úÖ Cross-platform –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞');
            console.log('‚úÖ Emoji fallback —Å–∏—Å—Ç–µ–º–∞ –¥–ª—è Safari –≤–∫–ª—é—á–µ–Ω–∞');

            // Detect and setup for mobile/touch devices
            const isTouch = isTouchDevice();
            const isMobile = isMobileDevice();
            const isSafari = isIOSSafari();

            console.log('üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ:', {
                touch: isTouch,
                mobile: isMobile,
                safari: isSafari,
                dpr: devicePixelRatio
            });

            if (isTouch || isMobile) {
                console.log('üì± –í–∫–ª—é—á–µ–Ω—ã –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è');
                setupTouchControls();

                // Hide controls hint for mobile
                const controlsHint = document.getElementById('controls');
                if (controlsHint) {
                    controlsHint.textContent = '–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–Ω–∏–∑—É';
                }
            }

            // iOS/Safari specific fixes
            if (isSafari) {
                console.log('üçé –ü—Ä–∏–º–µ–Ω–µ–Ω—ã Safari –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏');
                document.body.style.WebkitUserSelect = 'none';
                document.body.style.WebkitTouchCallout = 'none';
            }

            displayTip();

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—ã–π —Å–æ–≤–µ—Ç –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
            setInterval(() => {
                if (document.getElementById('menuScreen').classList.contains('active')) {
                    displayTip();
                }
            }, 10000);

            // –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å—ë –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
            console.log('–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏–≥—Ä—ã:');
            console.log('- input.keys:', Object.keys(input.keys).length === 0 ? '‚úÖ –ß–∏—Å—Ç–æ' : '‚ö†Ô∏è –°–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã–µ');
            console.log('- gameState.isRunning:', gameState.isRunning ? '–ó–∞–ø—É—â–µ–Ω–∞' : '‚úÖ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');
            console.log('- gameLoopSafetyCounter:', gameLoopSafetyCounter);
        });
    </script>
</body>
</html>
